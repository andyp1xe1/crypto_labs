#+title: Caesar Cipher: Implementation & Extension
#+author: Andrei Chicu
#+OPTIONS: title:nil toc:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,12pt]
#+LATEX_HEADER: \input{lab_pre}
#+LATEX_HEADER: \labsubject{Cryptography}
#+LATEX_HEADER: \group{FAF--233}
#+LATEX_HEADER: \prof{Zaica, asist. univ.}
#+LATEX_HEADER: \profdep{sea, fcim utm}
#+LATEX_HEADER: \labno{1}
#+INCLUDE: "lab_titlepage.tex" export latex
#+PROPERTY: HEADER-ARGS+ :eval no-export

* Introduction
GitHub repository: \url{https://github.com/andyp1xe1/crypto_labs}

** Objective
The objective of this laboratory work is to implement the Caesar Cipher algorithm, covering both the standard fixed-shift version and an extended version that uses a keyword to permute the alphabet, significantly increasing the cipher's key space and cryptoresistance.

** Tasks
- Task 1.1: Standard Caesar Cipher (Single Key $k_{1}$)
- Task 1.2: Permutation Caesar Cipher (Two Keys $k_{1}$ and $k_{2}$)
- Task 1.3: Cipher Verification (Exchange and Decrypt)

** Theoretical Background
The Caesar cipher is a substitution cipher where each letter in the plaintext is shifted by a fixed number of positions in the alphabet. The standard Caesar cipher uses the following formulas:

- Encryption: $c = e_{k}(x) = (x + k) \bmod n$
- Decryption: $m = d_{k}(y) = (y - k) \bmod n$

where $n = 26$ for the English alphabet and the shift key $k \in \{1, 2, \ldots, 25\}$.

The permutation cipher modifies this by first reordering the alphabet using a keyword $k_{2}$, then applying the Caesar shift $k_{1}$ on the permuted alphabet. This increases the keyspace from 25 to approximately $26! \times 25 \approx 10^{28}$ possible keys.

* Implementation
** Task 1.1: Standard Caesar Cipher (Single Key)
*** Overview
The standard Caesar Cipher implementation uses a single integer key, $k_{1} \in [1, 25]$, for the alphabetic shift. The implementation is written in Go and provides a command-line interface for user interaction.
*** Implementation
**** Input Functions
The implementation includes robust input validation:
#+begin_src go
func getShiftKey(reader *bufio.Reader) int {
	for {
		fmt.Print("Enter the shift key (an integer between 1 and 25): ")
		keyStr, _ := reader.ReadString('\n')
		key, err := strconv.Atoi(strings.TrimSpace(keyStr))
		if err == nil && key >= 1 && key <= 25 {
			return key
		}
		fmt.Println("Invalid key. It must be an integer between 1 and 25.")
	}
}

func sanitizeText(input string) string {
	var builder strings.Builder
	for _, char := range input {
		if unicode.IsLetter(char) {
			builder.WriteRune(unicode.ToUpper(char))
		}
	}
	return builder.String()
}
#+end_src
The =getShiftKey= function validates that $k_{1}$ is an integer in the range $[1, 25]$, repeatedly prompting the user until valid input is provided.

The =sanitizeText= function ensures the input plaintext is converted to uppercase and all non-letter characters (including spaces) are removed, as required by the specification.

The encryption and decryption logic is implemented in the =processText= function:
#+begin_src go
func processText(inputText string, shiftKey int, currentAlphabet string, 
                 op CipherOp) (string, error) {
	charToIndex := make(map[rune]int)
	for i, char := range currentAlphabet {
		charToIndex[char] = i
	}

	sanitizedText := sanitizeText(inputText)
	var result strings.Builder
	alphabetSize := len(currentAlphabet)

	for _, char := range sanitizedText {
		index, ok := charToIndex[char]
		if !ok {
			continue
		}

		var newIndex int
		switch op {
		case Encrypt:
			newIndex = (index + shiftKey) % alphabetSize
		case Decrypt:
			newIndex = (index - shiftKey + alphabetSize) % alphabetSize
		}

		result.WriteRune([]rune(currentAlphabet)[newIndex])
	}

	return result.String(), nil
}
#+end_src
The function:
1. Creates a character-to-index mapping from the provided alphabet
2. Sanitizes the input text
3. For each character, calculates the new position using modular arithmetic:
   - Encryption: =(index + k) mod 26=
   - Decryption: =(index - k + 26) mod 26=
4. Returns the transformed text

The results are shown in Figures [[fig:stdenc]], [[fig:stddec]]
#+CAPTION: Standard Caesar Encryption
#+NAME: fig:stdenc
[[./results/caesar_enc.png]]

#+NAME: fig:stddec
#+CAPTION: Standard Caesar Decryption
[[./results/caesar_dec.png]]

** Task 1.2: Permutation Caesar Cipher (Two Keys)
*** Overview
This extended cipher uses both a shift key $k_{1}$ (integer) and a permutation key $k_{2}$ (keyword string) to create a custom alphabet ordering before applying the Caesar shift.
*** Implementation
The =getPermutationKey= function validates that $k_{2}$:
- Contains only alphabetic characters
- Has a minimum length of 7 characters
#+begin_src go
func getPermutationKey(reader *bufio.Reader) string {
	for {
		fmt.Print("Enter the permutation keyword (at least 7 letters long, " +
		          "no numbers/symbols): ")
		key, _ := reader.ReadString('\n')
		key = strings.TrimSpace(key)

		cleanKey := sanitizeText(key)

		if len(cleanKey) < 7 {
			fmt.Println("Invalid keyword. It must contain at least 7 letters.")
			continue
		}
		if len(cleanKey) != len(key) {
			fmt.Println("Invalid keyword. It must contain only letters " +
			            "('A'-'Z', 'a'-'z').")
			continue
		}
		return key
	}
}
#+end_src
The =generatePermutedAlphabet= function sanitizes and uppercases the keyword $k_{2}$, appends unique letters from $k_{2}$ to the new alphabet in order of first appearance, appends remaining standard alphabet letters (A-Z) not in $k_{2}$ in their natural order.
#+begin_src go
func generatePermutedAlphabet(keyword string) string {
	var builder strings.Builder
	seen := make(map[rune]bool)

	// Add unique characters from the keyword first
	for _, char := range strings.ToUpper(keyword) {
		if !seen[char] {
			builder.WriteRune(char)
			seen[char] = true
		}
	}

	// Add the rest of the alphabet
	for _, char := range alphabet {
		if !seen[char] {
			builder.WriteRune(char)
		}
	}

	return builder.String()
}
#+end_src

The results are shown in Figures [[fig:extenc]], [[fig:extdec]]
#+CAPTION: Extended Caesar Encryption
#+NAME: fig:extenc
[[./results/extended_caesar_enc.png]]

#+NAME: fig:extdec
#+CAPTION: Extended Caesar Decryption
[[./results/extended_caesar_dec.png]]

** Task 1.3: Cipher Verification (Exchange and Decrypt)
*** Objective
This task verifies the practical application of the Permutation Caesar Cipher through a peer exchange, where two students encrypt messages and exchange them for decryption verification.
*** Exchange Results
*My Encryption:*
- Original message: =TESTMESSAGE=
- Shift key ($k_{1}$): =7=
- Permutation key ($k_{2}$): =SECURITY=
- Generated permuted alphabet: =SECURITYABDFGHJKLMNOPQVWXZ=
- Resulting ciphertext: =HAYHXAYYKOA=
*Partner's Encryption:*
- Received ciphertext: =XZHHIXJZB=
- Provided shift key ($k_{1}$): =4=
- Provided permutation key ($k_{2}$): =MOLDOVA=
- Generated permuted alphabet: =MOLDVABCEFGHIJKNPQRSTUWXYZ=
- Decrypted message: =SUCCESSFUL=
Both encryption and decryption processes were successful. The decrypted message matched the partner's original plaintext, confirming correct implementation of the permutation Caesar cipher algorithm.

* Testing and Results
The implementation has been thoroughly tested with automated unit tests. The test results are shown in Figure [[fig:tests]].
#+CAPTION: Test results
#+NAME: fig:tests
[[./results/tests.png]]

** Test Coverage
The following test cases have been implemented:
*** TestSanitizeText
Validates text sanitization functionality with various input patterns:
- Trailing spaces: ="hello world "= to =HELLOWORLD=
- Standard text: ="hello_world"= to =HELLOWORLD=
- Greeting variations: ="Hello, World!"= to =HELLOWORLD=
- Alphanumeric combinations: ="123 ABC xyz 456"= to =ABCXYZ=
- Special character handling: ="!@#$%^&*()_+"= to =""=
- Leading space removal: =" test"= to =TEST=
*** TestGeneratePermutedAlphabet
Tests alphabet permutation generation:
- Standard example from specification: ="cryptography"= to =CRYPTOGAHBDEFIJKLMNQSUVWXZ=
- Keywords with repeated letters: ="ABRACADABRA"= to =ABRCDEFGHIJKLMNOPQSTUVWXYZ=
- Full alphabet as keyword input
*** TestProcessText
Verifies encryption/decryption operations:
- Standard encryption with wrapping (e.g., =XYZ= with $k=5$ â†’ =CDE=)
- Standard encryption without wrapping (e.g., =ABC= with $k=3$ â†’ =DEF=)
- Standard decryption with wrapping (e.g., =ABC= with $k=3$ â†’ =XYZ=)
- Standard decryption without wrapping
- Permutation-based encryption with verified logic
- Permutation-based decryption (reverse operation)
- Full cycle tests (encrypt then decrypt) for both standard and permutation methods
** Security Analysis
*Standard Caesar Cipher:*
Has a keyspace of 25 possible keys.
Easily broken by exhaustive key search (brute force).
*Permutation Caesar Cipher:*
Keyspace is $26! \times 25$. Exhaustive key search becomes computationally infeasible, but it is vulnerable to frequency analysis attacks, and remains a monoalphabetic substitution cipher
(each plaintext letter always maps to the same ciphertext letter).
* Conclusions
This laboratory work successfully implemented the Caesar Cipher and its permutation-enhanced extension. The use of a permutation keyword significantly complicates an exhaustive key search compared to the standard version, although the cipher remains vulnerable to frequency analysis. All requirements regarding text sanitization (uppercase, no non-letters) and key validation (\(k_{1}\in[1,25], len(k_{2})\ge7\)) were met in the implementation.
